minimum<-min(df$x)
maximum<-max(df$x)
spacing <- (maximum-minimum)/(seg-1)
df$cutX <- cut(df$x, breaks = seq(minimum-1,maximum+1,spacing))
df$cutY <- cut(df$y, breaks = seq(min(df$y)-1,max(df$y)+1,spacing))
mVal = plyr::ddply(df, .(cutX, cutY), summarize, mean = mean(dx))
mVal$cutX = as.character(mVal$cutX)
mVal$cutX = unlist(strsplit(mVal$cutX, ","))[c(T,F)]
mVal$cutX = as.numeric(sub("\\(", "", mVal$cutX))+spacing/2
mVal$cutY = as.character(mVal$cutY)
mVal$cutY = unlist(strsplit(mVal$cutY, ","))[c(T,F)]
mVal$cutY = as.numeric(sub("\\(", "", mVal$cutY))+spacing/2
#coordinates(mVal) = ~cutX +cutY
#gridded(mVal) = TRUE
#mergedx <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dx))
mergedy <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dy))
final=data.frame(x=mVal$cutX,y=mVal$cutY, dx=mVal$mean,dy=mergedy$mean)
final$vel=final$dx^2+final$dy^2
if (normalize==TRUE) {
final$dx <- (final$dx/sqrt(final$vel))*spacing
final$dy <- (final$dy/sqrt(final$vel))*spacing
}
print(max(final$y))
ggplot(final, aes(x = x, y = y))+scale_colour_continuous(low = "grey80", high = "darkred")+geom_raster(aes(fill=vel))+geom_segment(aes(xend = x + dx, yend = y + dy, colour="red"),size = 0.3, arrow = arrow(length = unit(0.2, "cm")))
#ggplot(final, aes(x=x,y=y)) +geom_raster(aes(fill=vel))+ metR::geom_streamline(data = final, aes(dx = dx, dy = dy),L = 1.75, res = 1, n = 60, jitter =150)
}
plotuj(df,15, T)
plotuj(df2,30) #Curl
plotuj <- function(df,seg,normalize=FALSE) {
library(ggplot2)
library(plyr)
minimum<-min(df$x)
maximum<-max(df$x)
spacing <- (maximum-minimum)/(seg-1)
df$cutX <- cut(df$x, breaks = seq(minimum-1,maximum+1,spacing))
df$cutY <- cut(df$y, breaks = seq(min(df$y)-1,max(df$y)+1,spacing))
mVal = plyr::ddply(df, .(cutX, cutY), summarize, mean = mean(dx))
mVal$cutX = as.character(mVal$cutX)
mVal$cutX = unlist(strsplit(mVal$cutX, ","))[c(T,F)]
mVal$cutX = as.numeric(sub("\\(", "", mVal$cutX))+spacing/2
mVal$cutY = as.character(mVal$cutY)
mVal$cutY = unlist(strsplit(mVal$cutY, ","))[c(T,F)]
mVal$cutY = as.numeric(sub("\\(", "", mVal$cutY))+spacing/2
#coordinates(mVal) = ~cutX +cutY
#gridded(mVal) = TRUE
#mergedx <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dx))
mergedy <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dy))
final=data.frame(x=mVal$cutX,y=mVal$cutY, dx=mVal$mean,dy=mergedy$mean)
final$vel=final$dx^2+final$dy^2
if (normalize==TRUE) {
final$dx <- (final$dx/sqrt(final$vel))*spacing
final$dy <- (final$dy/sqrt(final$vel))*spacing
}
print(max(final$y))
ggplot(final, aes(x = x, y = y))+scale_colour_continuous(low = "grey80", high = "darkred")+geom_raster(aes(fill=vel))+geom_segment(aes(xend = x + dx, yend = y + dy),size = 0.3, arrow = arrow(length = unit(0.2, "cm")))
#ggplot(final, aes(x=x,y=y)) +geom_raster(aes(fill=vel))+ metR::geom_streamline(data = final, aes(dx = dx, dy = dy),L = 1.75, res = 1, n = 60, jitter =150)
}
plotuj(df,15) #DeRahm
plotuj(df,15, T)
plotuj(df2,30) #Curl
plotuj(df2,30, T)
plotuj(df3,15) #Gradient
plotuj(df3,30, T)
library(HodgePaths)
vplot(df4,30,T)
devtools::load_all(".")
vplot(df4,30,T)
vplot(df4,30)
library(HodgePaths)
library(HodgePaths)
devtools::load_all(".")
set.seed(123)
x<-runif(n = 3000,min = 0,max = 1)
y<-runif(n = 3000,min = 0,max = 1)
xy<-cbind(x=x,y=y)
plot(xy)
ss<-which((x-0.5)^2+(y-0.5)^2<0.04)
X<-xy[-ss,]
#X<-xy
plot(X)
#TECNY POLE
jednicky=replicate(nrow(X), 1)
tezistebodu=(Matrix::t(X)%*%jednicky)/(nrow(X))
maticeteziste=matrix(replicate(nrow(X),tezistebodu),nrow=2)
vektorydoteziste=maticeteziste-Matrix::t(X)
tecnypole <- Matrix::t(vektorydoteziste)%*%cbind(c(0,-1),c(1,0))
gradientpole <- matrix(replicate(nrow(X),c(1,1)),ncol=2)
gradientpole <- (gradientpole)/5
tecnypole <- (tecnypole)/2
Vpole <- ((tecnypole))+gradientpole
drawfield(X,Vpole, 1)
drawfield(X,tecnypole, 1)
drawfield(X,gradientpole, 1)
#Filtrace
flt<-TDA::alphaComplexFiltration(X)
flt$cmplx<-flt$cmplx[-length(flt$cmplx)] ##odstranim 2-simplex s nejvyssi filtracni hodnotou
Bu=build_boundary_Cu(flt$cmplx)
cmplx <- Bu
BB<-complex_to_boundaryF(cmplx = cmplx)
derahm<-deRahmMap1f(BB[[1]],X,Vpole) #derahmovo zobrazeni na 1simplexy
out <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,derahm)
drawfield(out$BC,out$oneform, 1)
title("Whitney DeRahmu")
vysledekrozkladu <- HodgeDecomp(BB,derahm,"minres") #Dekompozice
whitneyyg <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[1]])
whitneyyc <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[2]])
whitneyyh <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[3]])
df <- makedf(out)
df2 <- makedf(whitneyyc)
df3 <- makedf(whitneyyg)
df4 <- makedf(whitneyyh)
plotuj(df,15) #DeRahm
plotuj(df,15, T)
vplot(df,15) #DeRahm
vplot(df,15, T)
vplot(df2,30) #Curl
vplot(df2,30, T)
vplot(df3,15) #Gradient
vplot(df3,30, T)
vplot(df4,30)
vplot(df4,30,T) #Harmonic
drawfield(X,Vpole, 1)
vdf=data.drame(x=X[,1],y=X[,2],dx=Vpole[,1],dy=Vpole[,2])
vdf=data.frame(x=X[,1],y=X[,2],dx=Vpole[,1],dy=Vpole[,2])
vplot(vdf,50)
vplot(vdf,20)
vplot(vfielddf,20)
vfielddf=data.frame(x=X[,1],y=X[,2],dx=Vpole[,1],dy=Vpole[,2])
tecnypoledf=data.frame(x=X[,1],y=X[,2],dx=tecnypole[,1],dy=tecnypole[,2])
vdf=data.frame(x=X[,1],y=X[,2],dx=gradientpole[,1],dy=gradientpole[,2])
vplot(vfielddf,20)
vplot(tecnypoledf,20)
vplot(gradientpole, 20)
vplot(tecnypoledf,20)
vplot(gradientpoledf, 20)
gradientpoledf=data.frame(x=X[,1],y=X[,2],dx=gradientpole[,1],dy=gradientpole[,2])
vplot(gradientpoledf, 20)
vplot(tecnypoledf,20)
vplot(tecnypoledf,20,T)
vplot(tecnypoledf,20)
vplot(gradientpoledf, 20)
vplot(vfielddf,20)
#Filtrace
flt<-TDA::alphaComplexFiltration(X)
flt$cmplx<-flt$cmplx[-length(flt$cmplx)] ##odstranim 2-simplex s nejvyssi filtracni hodnotou
Bu=build_boundary_Cu(flt$cmplx)
cmplx <- Bu
BB<-complex_to_boundaryF(cmplx = cmplx)
derahm<-deRahmMap1f(BB[[1]],X,Vpole) #derahmovo zobrazeni na 1simplexy
out <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,derahm)
drawfield(out$BC,out$oneform, 1)
title("Whitney DeRahmu")
vysledekrozkladu <- HodgeDecomp(BB,derahm,"minres") #Dekompozice
whitneyyg <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[1]])
whitneyyc <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[2]])
whitneyyh <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[3]])
df <- makedf(out)
df2 <- makedf(whitneyyc)
df3 <- makedf(whitneyyg)
df4 <- makedf(whitneyyh)
vplot(df,15) #DeRahm
vplot(df,15, T)
vplot(df2,30) #Curl
vplot(df2,30, T)
vplot(df3,15) #Gradient
vplot(df3,30, T)
vplot(df4,30)
vplot(df4,30,T) #Harmonic
#X<-xy
plot(X)
library(HodgePaths)
vplot(df4,30) #Harmonic
vplot(df3,15) #Gradient
vplot(df3,30, T)
vplot(df4,30,T)
vplot(df,15, T)
vplot(df2,30) #Curl
vplot(df2,30, T)
library(HodgePaths)
vplot(df,15, T,mean)
vplot(df,15, T,mean)
vplot(df,15, T,plyr::mean)
library(HodgePaths)
library(HodgePaths)
vplot(df,15, T)
vplot(df,15, T, mean)
library(HodgePaths)
vplot(df,15,F)  #DeRahm
vplot(df,15,T)
vplot(df2,30,F) #Curl
vplot(df2,30,F,"median") #Curl
vplot(df4,30,F,"mean") #Harmonic mean
vplot(df4,30,F,"median") #Harmonic median
vplot(df4,30,T)
vplot(df4,30,T,"median")
vplot(df4,30,T,"mean")
vplot(df4,30,T,"median")
vplot(df4,30,T,"mean")
vplot(df4,30,T,"median")
#'
#' @param df dataframe with $x $y $dx, $dy being a vector field
#' @param seg #into how many segments do you want to average out a vector field
#' @param normalize TRUE or FALSE if you wish to normalize vectors when they are displayed
#' @param fc function for averiging vectors in cell ("mean"/"median")
#'
#' @return
#' @export
#'
#' @examples vplot(df2,30, T, "mean")
vplot <- function(df,seg,normalize=FALSE,fc="mean") {
library(ggplot2)
library(plyr)
minimum<-min(df$x)
maximum<-max(df$x)
spacing <- (maximum-minimum)/(seg-1)
df$cutX <- cut(df$x, breaks = seq(minimum-1,maximum+1,spacing))
df$cutY <- cut(df$y, breaks = seq(min(df$y)-1,max(df$y)+1,spacing))
if (fc=="mean") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=mean(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = mean(dx)) }
if (fc=="median") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=median(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = median(dx)) }
mVal$cutX = as.character(mVal$cutX)
mVal$cutX = unlist(strsplit(mVal$cutX, ","))[c(T,F)]
mVal$cutX = as.numeric(sub("\\(", "", mVal$cutX))+spacing/2
mVal$cutY = as.character(mVal$cutY)
mVal$cutY = unlist(strsplit(mVal$cutY, ","))[c(T,F)]
mVal$cutY = as.numeric(sub("\\(", "", mVal$cutY))+spacing/2
#coordinates(mVal) = ~cutX +cutY
#gridded(mVal) = TRUE
#mergedx <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dx))
final=data.frame(x=mVal$cutX,y=mVal$cutY, dx=mVal$mean,dy=mergedy$mean)
final$vel=final$dx^2+final$dy^2
if (normalize==TRUE) {
final$dx <- (final$dx/sqrt(final$vel))*spacing
final$dy <- (final$dy/sqrt(final$vel))*spacing
}
ggplot(final, aes(x = x, y = y))+scale_fill_gradientn(colours=c("blue","yellow"))+geom_raster(aes(fill=vel))+geom_segment(aes(xend = x + dx, yend = y + dy),size = 0.3, arrow = arrow(length = unit(0.2, "cm")))
#ggplot(final, aes(x=x,y=y)) +geom_raster(aes(fill=vel))+ metR::geom_streamline(data = final, aes(dx = dx, dy = dy),L = 1.75, res = 1, n = 60, jitter =150)
}
vplot(df4,30,T,"mean")
vplot(df,15,F)  #DeRahm
#'
#' @param df dataframe with $x $y $dx, $dy being a vector field
#' @param seg #into how many segments do you want to average out a vector field
#' @param normalize TRUE or FALSE if you wish to normalize vectors when they are displayed
#' @param fc function for averiging vectors in cell ("mean"/"median")
#'
#' @return
#' @export
#'
#' @examples vplot(df2,30, T, "mean")
vplot <- function(df,seg,normalize=FALSE,fc="mean") {
library(ggplot2)
library(plyr)
minimum<-min(df$x)
maximum<-max(df$x)
spacing <- (maximum-minimum)/(seg-1)
df$cutX <- cut(df$x, breaks = seq(minimum-1,maximum+1,spacing))
df$cutY <- cut(df$y, breaks = seq(min(df$y)-1,max(df$y)+1,spacing))
if (fc=="mean") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=mean(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = mean(dx)) }
if (fc=="median") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=median(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = median(dx)) }
mVal$cutX = as.character(mVal$cutX)
mVal$cutX = unlist(strsplit(mVal$cutX, ","))[c(T,F)]
mVal$cutX = as.numeric(sub("\\(", "", mVal$cutX))+spacing/2
mVal$cutY = as.character(mVal$cutY)
mVal$cutY = unlist(strsplit(mVal$cutY, ","))[c(T,F)]
mVal$cutY = as.numeric(sub("\\(", "", mVal$cutY))+spacing/2
#coordinates(mVal) = ~cutX +cutY
#gridded(mVal) = TRUE
#mergedx <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dx))
final=data.frame(x=mVal$cutX,y=mVal$cutY, dx=mVal$mean,dy=mergedy$mean)
final$vel=final$dx^2+final$dy^2
if (normalize==TRUE) {
final$dx <- (final$dx/sqrt(final$vel))*spacing
final$dy <- (final$dy/sqrt(final$vel))*spacing
}
ggplot(final, aes(x = x, y = y))+scale_fill_gradientn(colours=c("darkblue","yellow"))+geom_raster(aes(fill=vel))+geom_segment(aes(xend = x + dx, yend = y + dy),size = 0.3, arrow = arrow(length = unit(0.2, "cm")))
#ggplot(final, aes(x=x,y=y)) +geom_raster(aes(fill=vel))+ metR::geom_streamline(data = final, aes(dx = dx, dy = dy),L = 1.75, res = 1, n = 60, jitter =150)
}
vplot(df,15,F)  #DeRahm
vplot(df2,30,F) #Curl
vplot(df2,30,T)
vplot(df3,15,F) #Gradient
vplot(df3,30,T)
vplot(df4,30,F,"mean") #Harmonic mean
vplot(df4,30,F,"median") #Harmonic median
vplot(df4,30,T,"mean")
vplot(df4,30,T,"median")
#'
#' @param df dataframe with $x $y $dx, $dy being a vector field
#' @param seg #into how many segments do you want to average out a vector field
#' @param normalize TRUE or FALSE if you wish to normalize vectors when they are displayed
#' @param fc function for averiging vectors in cell ("mean"/"median")
#'
#' @return
#' @export
#'
#' @examples vplot(df2,30, T, "mean")
vplot <- function(df,seg,normalize=FALSE,fc="mean") {
library(ggplot2)
library(plyr)
minimum<-min(df$x)
maximum<-max(df$x)
spacing <- (maximum-minimum)/(seg-1)
df$cutX <- cut(df$x, breaks = seq(minimum-1,maximum+1,spacing))
df$cutY <- cut(df$y, breaks = seq(min(df$y)-1,max(df$y)+1,spacing))
if (fc=="mean") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=mean(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = mean(dx)) }
if (fc=="median") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=median(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = median(dx)) }
mVal$cutX = as.character(mVal$cutX)
mVal$cutX = unlist(strsplit(mVal$cutX, ","))[c(T,F)]
mVal$cutX = as.numeric(sub("\\(", "", mVal$cutX))+spacing/2
mVal$cutY = as.character(mVal$cutY)
mVal$cutY = unlist(strsplit(mVal$cutY, ","))[c(T,F)]
mVal$cutY = as.numeric(sub("\\(", "", mVal$cutY))+spacing/2
#coordinates(mVal) = ~cutX +cutY
#gridded(mVal) = TRUE
#mergedx <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dx))
final=data.frame(x=mVal$cutX,y=mVal$cutY, dx=mVal$mean,dy=mergedy$mean)
final$vel=final$dx^2+final$dy^2
if (normalize==TRUE) {
final$dx <- (final$dx/sqrt(final$vel))*spacing
final$dy <- (final$dy/sqrt(final$vel))*spacing
}
ggplot(final, aes(x = x, y = y))+scale_fill_gradientn(colours=c("darkblue","green","yellow"))+geom_raster(aes(fill=vel))+geom_segment(aes(xend = x + dx, yend = y + dy),size = 0.3, arrow = arrow(length = unit(0.2, "cm")))
#ggplot(final, aes(x=x,y=y)) +geom_raster(aes(fill=vel))+ metR::geom_streamline(data = final, aes(dx = dx, dy = dy),L = 1.75, res = 1, n = 60, jitter =150)
}
vplot(df4,30,F,"median") #Harmonic median
vplot(df4,30,F,"mean") #Harmonic mean
vplot(df,15,F)  #DeRahm
#'
#' @param df dataframe with $x $y $dx, $dy being a vector field
#' @param seg #into how many segments do you want to average out a vector field
#' @param normalize TRUE or FALSE if you wish to normalize vectors when they are displayed
#' @param fc function for averiging vectors in cell ("mean"/"median")
#'
#' @return
#' @export
#'
#' @examples vplot(df2,30, T, "mean")
vplot <- function(df,seg,normalize=FALSE,fc="mean") {
library(ggplot2)
library(plyr)
minimum<-min(df$x)
maximum<-max(df$x)
spacing <- (maximum-minimum)/(seg-1)
df$cutX <- cut(df$x, breaks = seq(minimum-1,maximum+1,spacing))
df$cutY <- cut(df$y, breaks = seq(min(df$y)-1,max(df$y)+1,spacing))
if (fc=="mean") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=mean(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = mean(dx)) }
if (fc=="median") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=median(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = median(dx)) }
mVal$cutX = as.character(mVal$cutX)
mVal$cutX = unlist(strsplit(mVal$cutX, ","))[c(T,F)]
mVal$cutX = as.numeric(sub("\\(", "", mVal$cutX))+spacing/2
mVal$cutY = as.character(mVal$cutY)
mVal$cutY = unlist(strsplit(mVal$cutY, ","))[c(T,F)]
mVal$cutY = as.numeric(sub("\\(", "", mVal$cutY))+spacing/2
#coordinates(mVal) = ~cutX +cutY
#gridded(mVal) = TRUE
#mergedx <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dx))
final=data.frame(x=mVal$cutX,y=mVal$cutY, dx=mVal$mean,dy=mergedy$mean)
final$vel=final$dx^2+final$dy^2
if (normalize==TRUE) {
final$dx <- (final$dx/sqrt(final$vel))*spacing
final$dy <- (final$dy/sqrt(final$vel))*spacing
}
ggplot(final, aes(x = x, y = y))+scale_fill_gradientn(colours=c("darkblue","darkgreen","darkyellow","yellow"))+geom_raster(aes(fill=vel))+geom_segment(aes(xend = x + dx, yend = y + dy),size = 0.3, arrow = arrow(length = unit(0.2, "cm")))
#ggplot(final, aes(x=x,y=y)) +geom_raster(aes(fill=vel))+ metR::geom_streamline(data = final, aes(dx = dx, dy = dy),L = 1.75, res = 1, n = 60, jitter =150)
}
vplot(df4,30,F,"mean") #Harmonic mean
#'
#' @param df dataframe with $x $y $dx, $dy being a vector field
#' @param seg #into how many segments do you want to average out a vector field
#' @param normalize TRUE or FALSE if you wish to normalize vectors when they are displayed
#' @param fc function for averiging vectors in cell ("mean"/"median")
#'
#' @return
#' @export
#'
#' @examples vplot(df2,30, T, "mean")
vplot <- function(df,seg,normalize=FALSE,fc="mean") {
library(ggplot2)
library(plyr)
minimum<-min(df$x)
maximum<-max(df$x)
spacing <- (maximum-minimum)/(seg-1)
df$cutX <- cut(df$x, breaks = seq(minimum-1,maximum+1,spacing))
df$cutY <- cut(df$y, breaks = seq(min(df$y)-1,max(df$y)+1,spacing))
if (fc=="mean") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=mean(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = mean(dx)) }
if (fc=="median") {
mergedy <- ddply(df, .(cutX,cutY), summarize, mean=median(dy))
mVal = ddply(df, .(cutX, cutY), summarize, mean = median(dx)) }
mVal$cutX = as.character(mVal$cutX)
mVal$cutX = unlist(strsplit(mVal$cutX, ","))[c(T,F)]
mVal$cutX = as.numeric(sub("\\(", "", mVal$cutX))+spacing/2
mVal$cutY = as.character(mVal$cutY)
mVal$cutY = unlist(strsplit(mVal$cutY, ","))[c(T,F)]
mVal$cutY = as.numeric(sub("\\(", "", mVal$cutY))+spacing/2
#coordinates(mVal) = ~cutX +cutY
#gridded(mVal) = TRUE
#mergedx <- plyr::ddply(df, .(cutX,cutY), summarize, mean=mean(dx))
final=data.frame(x=mVal$cutX,y=mVal$cutY, dx=mVal$mean,dy=mergedy$mean)
final$vel=final$dx^2+final$dy^2
if (normalize==TRUE) {
final$dx <- (final$dx/sqrt(final$vel))*spacing
final$dy <- (final$dy/sqrt(final$vel))*spacing
}
ggplot(final, aes(x = x, y = y))+scale_fill_gradientn(colours=c("darkblue","darkgreen","yellow"))+geom_raster(aes(fill=vel))+geom_segment(aes(xend = x + dx, yend = y + dy),size = 0.3, arrow = arrow(length = unit(0.2, "cm")))
#ggplot(final, aes(x=x,y=y)) +geom_raster(aes(fill=vel))+ metR::geom_streamline(data = final, aes(dx = dx, dy = dy),L = 1.75, res = 1, n = 60, jitter =150)
}
vplot(df4,30,F,"mean") #Harmonic mean
vplot(df4,30,F,"median") #Harmonic median
vplot(df,15,F)  #DeRahm
vplot(df2,30,F) #Curl
vplot(df2,30,T)
vplot(df4,30,F,"mean") #Harmonic mean
vplot(df4,30,F,"median") #Harmonic median
vplot(df4,30,T,"mean")
vplot(df4,30,T,"median")
vplot(df,15,F)  #DeRahm
vplot(tecnypoledf,20)
vplot(gradientpoledf, 20)
vplot(vfielddf,20)
library(HodgePaths)
vplot(df,15,F)  #DeRahm
vplot(df,15,T)
vplot(df4,30,T,"mean")
vplot(df4,30,T,"median")
vplot(df,15,F)  #DeRahm
vplot(df,15,T)
vplot(df2,30,F) #Curl
vplot(df2,30,T)
vplot(df4,30,F,"median") #Harmonic field with median composition
vplot(df4,30,T,"median")
vplot(df2,30,T)
vplot(df4,10,T,"mean")
vplot(df4,5,T,"mean")
vplot(df4,4,T,"mean")
vplot(df4,3,T,"mean")
vplot(df4,2,T,"mean")
vplot(df3,15,F) #Gradient
vplot(df3,30,T)
vplot(df3,30,F) #Gradient
vplot(df3,30,T)
vplot(df3,10,T)
vplot(df3,5,T)
vplot(df3,2,T)
vplot(df3,1,T)
vplot(df3,30,T)
vplot(df,15,F)  #DeRahm
vplot(df2,4,T)
vplot(df2,30,T)
vplot(df,30,T)
vplot(df,3,T)
vplot(df,30,T)
set.seed(124)
x<-runif(n = 3000,min = 0,max = 1)
y<-runif(n = 3000,min = 0,max = 1)
xy<-cbind(x=x,y=y)
plot(xy)
ss<-which((x-0.5)^2+(y-0.5)^2<0.04)
X<-xy[-ss,]
#X<-xy
plot(X)
#TECNY POLE
jednicky=replicate(nrow(X), 1)
tezistebodu=(Matrix::t(X)%*%jednicky)/(nrow(X))
maticeteziste=matrix(replicate(nrow(X),tezistebodu),nrow=2)
vektorydoteziste=maticeteziste-Matrix::t(X)
tecnypole <- Matrix::t(vektorydoteziste)%*%cbind(c(0,-1),c(1,0))
gradientpole <- matrix(replicate(nrow(X),c(1,1)),ncol=2)
gradientpole <- (gradientpole)/5
tecnypole <- (tecnypole)/2
Vpole <- ((tecnypole))+gradientpole
vfielddf=data.frame(x=X[,1],y=X[,2],dx=Vpole[,1],dy=Vpole[,2])
tecnypoledf=data.frame(x=X[,1],y=X[,2],dx=tecnypole[,1],dy=tecnypole[,2])
gradientpoledf=data.frame(x=X[,1],y=X[,2],dx=gradientpole[,1],dy=gradientpole[,2])
vplot(tecnypoledf,20)
vplot(gradientpoledf, 20)
vplot(vfielddf,20)
#Filtrace
flt<-TDA::alphaComplexFiltration(X)
flt$cmplx<-flt$cmplx[-length(flt$cmplx)] ##odstranim 2-simplex s nejvyssi filtracni hodnotou
vplot(tecnypoledf,20)
vplot(gradientpoledf, 20)
vplot(vfielddf,20)
#Filtrace
flt<-TDA::alphaComplexFiltration(X)
flt$cmplx<-flt$cmplx[-length(flt$cmplx)] ##odstranim 2-simplex s nejvyssi filtracni hodnotou
Bu=build_boundary_Cu(flt$cmplx)
cmplx <- Bu
BB<-complex_to_boundaryF(cmplx = cmplx)
derahm<-deRahmMap1f(BB[[1]],X,Vpole) #derahmovo zobrazeni na 1simplexy
out <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,derahm)
vysledekrozkladu <- HodgeDecomp(BB,derahm,"minres") #Dekompozice
whitneyyg <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[1]])
whitneyyc <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[2]])
whitneyyh <- WhitneyMap1f_BC(cmplx,flt$cmplx,X,vysledekrozkladu[[3]])
